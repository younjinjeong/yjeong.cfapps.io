<!DOCTYPE html>
<html class="bg-dark-10">




<head>
  <meta charset="utf-8">
  <title> HTTP Trailers &middot; Pivotal Engineering Journal </title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="/pivotal-ui.css">
  <link rel="stylesheet" href="/styleguide.css">
  <link rel="stylesheet" href="/github.css">
  <link rel="stylesheet" href="/local.css">
  <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
  
  <link href="http://feeds.feedburner.com/PivotalEngineeringJournal" rel="alternate" type="application/rss+xml" title="Pivotal Engineering Journal" />
</head>


<body>
  <div class="container">
  <div id="single-banner" class="pbxxl">
    <div class="single-banner-inner"></div>
    <p class="txt-c mvn">
      <a href="/">
        <svg x="0px" y="0px" width="200px" viewBox="0 0 435 180">
          <rect fill="#01786E" width="435" height="180"/>
          <path fill="#FFFFFF" d="M138.9,65h-11V54.4h11V65z M138.9,125.5h-11V72.8h11V125.5z"/>
          <path fill="#FFFFFF" d="M202.2,72.8l-15.3,45.5c-2.6,7.4-7.3,8.4-11.1,8.4c-5.6,0-9-2.6-11-8.4l-12.7-37.8h-5v-7.7h13.2
          l13.1,42.3c0.6,1.8,0.9,2.9,2.5,2.9c1.7,0,2-1.1,2.5-2.9l13.4-42.3H202.2z"/>
          <path fill="#FFFFFF" d="M229.3,72.8c14.2,0,24.1,9.4,24.1,22.8v8.3c0,13.4-9.9,22.8-24.1,22.8c-14.2,0-24.1-9.4-24.1-22.8
          v-8.3C205.1,82.2,215.1,72.8,229.3,72.8 M229.3,118c8.5,0,13.8-6.4,13.8-14.1v-8.3c0-7.7-5.2-14.1-13.8-14.1
          c-9,0-13.8,6.4-13.8,14.1v8.3C215.5,111.6,220.5,118,229.3,118"/>
          <path fill="#FFFFFF" d="M341,74.5c-5.5-1.4-14-2.4-20.3-2.4c-14.4,0-23.4,9.1-23.4,23.7v5.8c0,14.6,8.9,23.9,23.4,23.9
          c0.3,0,2.9,0,4.1-0.1v-8.8c-0.4,0-3.7,0.1-4.1,0.1c-7.8,0-13.1-6-13.1-15v-5.8c0-9,5.3-15,13.1-15c3.5,0,8.9,0.3,10.8,0.7
          l0.6,0.1l0,43.9h11V76.3C343,75.4,343,75,341,74.5"/>
          <rect x="353.6" y="54.4" fill="#FFFFFF" width="11" height="71"/>
          <path fill="#FFFFFF" d="M89.7,54.4H70.5v71h11.4V64.3h6.7c1.4,0,2.6,0.1,3.8,0.1c9.9,0.2,14.7,4.1,14.7,11.8
          c0,0.3,0,0.5,0,0.8c0,7.1-3.9,11.8-14.7,11.8c-1,0-2.1,0-3.2,0c0,2.7,0,7.8,0,9.5c1.1,0.1,2.2,0.1,3.2,0.1
          c15.5,0,26.4-6.1,26.4-21.4c0-0.3,0-0.6,0-0.9C118.9,60.4,107,54.4,89.7,54.4"/>
          <path fill="#FFFFFF" d="M272.8,61.5v11.3h17.9v8.5h-17.9V112c0,4.8,3.1,4.9,7.5,4.9h10.4v8.5h-14c-10.4,0-15-4.1-15-13.5V63
          L272.8,61.5z"/>
          <path fill="#FFFFFF" d="M369.6,120.9c0-2.5,2-4.6,4.6-4.6c2.5,0,4.6,2.1,4.6,4.6c0,2.5-2,4.6-4.6,4.6
          C371.6,125.5,369.6,123.4,369.6,120.9z M374.2,116.9c-2.2,0-3.9,1.8-3.9,3.9c0,2.1,1.7,3.9,3.9,3.9c2.2,0,3.9-1.8,3.9-3.9
          C378.1,118.7,376.3,116.9,374.2,116.9z M373.2,123.3h-0.5v-5c0,0,1.4,0,1.4,0c1.3,0,1.9,0.6,1.9,1.5c0,0.7-0.4,1.2-1,1.4l1.3,2.1
          h-0.6l-1.2-1.9l-1.2,0.1V123.3z M374.1,120.9c0.8,0,1.3-0.4,1.3-1.1c0-0.7-0.4-1.1-1.4-1.1c0,0-0.8,0-0.8,0v2.2L374.1,120.9z"/>
        </svg>
      </a>
    </p>
    <div class="container txt-c mvxl">
      <h1 class="title type-dark-9 mvn" id="main-title"><a href="/" class="type-dark-11 em-low title">Pivotal Engineering Journal</a></h1>
      <h3 class="type-dark-9 mvn">Technical articles from Pivotal engineers.</h3>
      
    </div>
  </div>
</div>

  <div class="container">
    <div id="post" class="bg-neutral-11 pbxxxl">
      <div class="post-header">
        <div class="phxxl pvl">
          <h1 class="title em-low type-dark-1 mvn">
            
            HTTP Trailers
          </h1>
          <h2 class="h3 type-dark-3 em-default mvn post-summary">Signaling failure during an HTTP stream</h2>
          <div class="type-dark-5 em-default">
            Posted on
            <span class="post-date"> Thu, Nov 5, 2015 </span>
            
            
            by
            <ul class="authors">
            
              
                <li>
                  
                    <a href="https://twitter.com/materialdesignr">Chris Hendrix</a>
                  
                </li>
              
            
            </ul>
            <br>
            
              Categories: &nbsp;
                
                  <a href="/categories/golang">Golang</a> &nbsp;&nbsp;
                
                  <a href="/categories/http">HTTP</a> &nbsp;&nbsp;
                
                  <a href="/categories/mysql">MySQL</a> &nbsp;&nbsp;
                
                <br/>
              </span>
            
            <a href="https://github.com/pivotal-cf/blog/edit/master/content/post/http-trailers.md" class="type-sm">Edit this post on GitHub.</a>
            <div class="pull-right">
              <a href="https://twitter.com/share" class="twitter-share-button"{count} data-via="materialdesignr ">Tweet</a>
              <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
            </div>
          </div>
          <hr />
        </div>
      </div>
      <div class="panel-body phxxl pvn">
        

<h2 id="motivation:fb23379a7294d4396e59cd58c49f7f79">Motivation</h2>

<p>We, the core-services team, are responsible for the MySQL service. This service runs alongside a Cloud Foundry installation and creates MySQL databases for your Cloud Foundry applications to use.</p>

<p>Operators have been requesting automated database backups so they can restore their MySQL instances in case of failure. A MySQL backup is a tarball containing all the data in the MySQL instance, which can become very large. We ultimately want to upload that file to S3 or another external blobstore so that it will be available to recreate the MySQL instance if it is destroyed.</p>

<p>When the MySQL server gets a request to take a backup, it can do one of two things:</p>

<ul>
<li>First generate the backup on local disk and then upload it to our blobstore</li>
<li>Generate it and stream it as it&rsquo;s being generated.</li>
</ul>

<p>The problem with the two-step generate-then-upload approach is that we would have to reserve twice as much space on the MySQL server&rsquo;s file system as we would otherwise need.</p>

<p>We settled on trying to generate and simultaneously stream the backup.</p>

<h2 id="streaming-in-http:fb23379a7294d4396e59cd58c49f7f79">Streaming in HTTP</h2>

<p>In HTTP/1.0, you had to specify the length of your response in advance via the Content-Length Header field. HTTP/1.1 removed that limitation, allowing senders to stream content, with the addition of <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.6.1">Chunked Transfer Coding</a>. According to <a href="https://en.wikipedia.org/wiki/Chunked_transfer_encoding">Wikipedia</a>, this enabled &ldquo;senders [to] begin transmitting dynamically-generated content before knowing the total size of that content.&rdquo;</p>

<h2 id="the-problems-with-streaming-in-http:fb23379a7294d4396e59cd58c49f7f79">The problems with streaming in HTTP</h2>

<p>The first problem we encountered when trying to stream data as it&rsquo;s generated is how to indicate failure.</p>

<p>In a traditional HTTP response, if something went wrong during the processing of the request, you would use the HTTP status code of 5xx to indicate a failure.</p>

<p>An HTTP status code is actually encoded in the <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html#sec6.1">Status Line</a> of the raw response, the first line of the response as seen below (HTTP/1.1 200 OK):</p>

<pre><code class="language-no-language">$ curl -i --raw http://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html#sec6.1

HTTP/1.1 200 OK
Date: Thu, 23 Jul 2015 21:41:00 GMT
Server: Apache/2
Last-Modified: Wed, 01 Sep 2004 13:24:52 GMT
ETag: &quot;277f-3e3073913b100&quot;
Accept-Ranges: bytes
Content-Length: 10111
Cache-Control: max-age=21600
Expires: Fri, 24 Jul 2015 03:41:00 GMT
P3P: policyref=&quot;http://www.w3.org/2014/08/p3p.xml&quot;
Content-Type: text/html; charset=iso-8859-1

&lt;RESPONSE BODY&gt;
</code></pre>

<p>Notice that the response body begins after all of the headers, including the status code. This means that by the time you start streaming back data, the status code has already been sent. If an issue occurs in the middle of streaming, there is no way of going back and changing the status code.</p>

<p>So how do you indicate that there was a failure in the land of streaming responses?</p>

<h2 id="enter-http-trailers:fb23379a7294d4396e59cd58c49f7f79">Enter HTTP Trailers</h2>

<p>If you had a way of sending metadata at the end of the response, then no matter when an error occurs, you could stop the streaming and send an error description.</p>

<p>HTTP Trailers are like HTTP Headers sent at the end of an HTTP response. They can be used to send metadata separate from the response body. Trailers are only available when using Chunked Transfer Coding.</p>

<p>Even though trailers are a part of the official HTTP spec, they are rarely used. According to the Golang documentation, &ldquo;few HTTP clients, servers, or proxies support HTTP trailers.&rdquo;</p>

<h2 id="http-1-1-trailer-spec:fb23379a7294d4396e59cd58c49f7f79">HTTP/1.1 Trailer Spec</h2>

<p>HTTP Trailers are implemented in two parts. First, you must send a regular HTTP Header listing the trailers that you will eventually send.</p>

<pre><code class="language-no-language">Trailer: X-Streaming-Error
</code></pre>

<p>Second, you must send your trailers at the end of your response. A Chunked Transfer Coding response looks like</p>

<pre><code>Chunked-Body = *chunk
               last-chunk
               trailer
               CRLF
</code></pre>

<p>Your trailers are sandwiched between the last-chunk you send and the CRLF that indicates the end of the response.</p>

<h2 id="implementation:fb23379a7294d4396e59cd58c49f7f79">Implementation</h2>

<h4 id="go-1-4:fb23379a7294d4396e59cd58c49f7f79">Go 1.4</h4>

<p>Golang provides the HTTP <a href="http://golang.org/pkg/net/http/#ResponseWriter">ResponseWriter</a> interface for writing the headers and body of an HTTP response. Unfortunately, in Go 1.4, the <code>ResponseWriter</code> interface does not support writing trailers. <a href="https://github.com/golang/go/issues/7759">This issue</a> has been filed in the golang github repo.</p>

<p>As described in that issue, we can use the HTTP <code>Hijacker</code> object as a work-around to take over the connection and write raw HTTP data directly:</p>

<pre><code class="language-go">func (b *BackupHandler) ServeHTTP(writer http.ResponseWriter, r *http.Request) {
    trailerKey := http.CanonicalHeaderKey(&quot;X-Streaming-Error&quot;)

    // NOTE: We set this in the Header because of the HTTP spec
    // http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.40
    // Even though we cannot test it, because the `net/http.Get()` strips
    // &quot;Trailer&quot; out of the Header
    writer.Header().Set(&quot;Trailer&quot;, trailerKey)

    err := runBackupProcessAndWriteTo(writer)

    errorString := &quot;&quot;
    if err != nil {
        errorString = err.Error()
    }

    writeTrailer(writer, trailerKey, errorString)
}

func writeTrailer(writer http.ResponseWriter, key string, value string) {
    trailers := http.Header{}
    trailers.Set(key, value)

    writer.(http.Flusher).Flush()
    conn, buf, _ := writer.(http.Hijacker).Hijack()

    buf.WriteString(&quot;0\r\n&quot;) // eof
    trailers.Write(buf)

    buf.WriteString(&quot;\r\n&quot;) // end of trailers
    buf.Flush()
    conn.Close()
}
</code></pre>

<p>The trailers from the response are stored in the <a href="http://golang.org/src/net/http/response.go?s=2161:2254"><code>Response.Trailer</code></a> field, which is of type <code>Header</code> (just a <code>map[string][]string</code>). It&rsquo;s important to note that this field will not be populated until you finish reading the entire response body.</p>

<pre><code class="language-go">It(&quot;has HTTP 200 status code but writes the error to the trailer&quot;, func() {
    resp, err := http.Get(backupUrl)    Expect(err).ShouldNot(HaveOccurred())

    Expect(resp.StatusCode).To(Equal(200))

    // NOTE: You must read the body from the response in order to populate the response's
    // trailers
    body, err := ioutil.ReadAll(resp.Body)
    Expect(err).ShouldNot(HaveOccurred())
    Expect(body).To(Equal([]byte(&quot;hello&quot;))) // data sent before the error occurred

    t := resp.Trailer.Get(http.CanonicalHeaderKey(&quot;X-Streaming-Error&quot;))
    Expect(t).To(ContainSubstring(&quot;exit status 1&quot;))
})
</code></pre>

<h4 id="go-1-5:fb23379a7294d4396e59cd58c49f7f79">Go 1.5</h4>

<p>In <a href="http://tip.golang.org/doc/go1.5">Go 1.5</a>, the ability to write trailers should be supported natively by <a href="http://tip.golang.org/pkg/net/http/#example_ResponseWriter_trailers"><code>ResponseWriter</code></a>:</p>

<pre><code class="language-go">mux := http.NewServeMux()
mux.HandleFunc(&quot;/sendstrailers&quot;, func(w http.ResponseWriter, req *http.Request) {
    // Before any call to WriteHeader or Write, declare
    // the trailers you will set during the HTTP
    // response. These three headers are actually sent in
    // the trailer.
    w.Header().Set(&quot;Trailer&quot;, &quot;AtEnd1, AtEnd2&quot;)
    w.Header().Add(&quot;Trailer&quot;, &quot;AtEnd3&quot;)

    w.Header().Set(&quot;Content-Type&quot;, &quot;text/plain; charset=utf-8&quot;) // normal header
    w.WriteHeader(http.StatusOK)

    w.Header().Set(&quot;AtEnd1&quot;, &quot;value 1&quot;)
    io.WriteString(w, &quot;This HTTP response has both headers before this text and trailers at the end.\n&quot;)
    w.Header().Set(&quot;AtEnd2&quot;, &quot;value 2&quot;)
    w.Header().Set(&quot;AtEnd3&quot;, &quot;value 3&quot;) // These will appear as trailers.
})
</code></pre>

<hr />

<p>Happy Hacking,</p>

<p>Chris Hendrix + Evan Short on behalf of the CF Core Services team</p>

      </div>
    </div>
  </div>
  <link rel="stylesheet" href="/css/highlight-github.css">
<script src="/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

</body>
</html>
